// SPDX-FileCopyrightText: 2017 Ben Gotow <ben@foundry376.com>
// SPDX-FileCopyrightText: 2023 Devin Lin <devin@kde.org>
// SPDX-License-Identifier: GPL-3.0-or-later

// Much of the logic is based on https://github.com/Foundry376/Mailspring-Sync/blob/master/MailSync/MailProcessor.cpp

#include "../libraven/constants.h"
#include "../libraven/models/file.h"
#include "../libraven/utils.h"
#include "mailprocessor.h"

MailProcessor::MailProcessor(QObject *parent, AccountWorker *worker)
    : QObject{parent}
    , m_worker{worker}
{
}

class CleanHTMLBodyRendererTemplateCallback : public Object, public HTMLRendererTemplateCallback {
    mailcore::String * templateForMainHeader(MessageHeader *header) override {
        Q_UNUSED(header)
        return MCSTR("");
    }

    mailcore::String * templateForAttachment(AbstractPart * part) override {
        Q_UNUSED(part)
        return MCSTR("");
    }

    mailcore::String * templateForAttachmentSeparator() override {
        return MCSTR("");
    }

    // Normally this calls through to XMLTidy but we have our own sanitizer at the Javascript
    // level and Tidy has led to some bugs due to its very strict parsing:
    // https://github.com/Foundry376/Mailspring/issues/301#issuecomment-342265351
    mailcore::String * cleanHTMLForPart(mailcore::String * html) override {
        return html;
    }
};

QString stringByAppendingOrSkipping(QString input, QString val) {
    QString valWithSpace = QStringLiteral(" ") + val;
    if (input.indexOf(valWithSpace) != -1) {
        return input;
    }
    return input + valWithSpace;
}

std::shared_ptr<Message> MailProcessor::insertFallbackToUpdateMessage(IMAPMessage *mMsg, Folder &folder, time_t syncDataTimestamp) {
    // try {
        return insertMessage(mMsg, folder, syncDataTimestamp);
    // } catch (const SQLite::Exception & ex) {
    //     if (ex.getErrorCode() != 19) { // constraint failed
    //         throw;
    //     }
    //     Query q = Query().equal("id", MailUtils::idForMessage(folder.accountId(), folder.path(), mMsg));
    //     auto localMessage = store->find<Message>(q);
    //     if (localMessage.get() == nullptr) {
    //         throw;
    //     }
    //
    //     // TODO: just set the properties and save to db
    //     updateMessage(localMessage.get(), mMsg, folder, syncDataTimestamp);
    //     return localMessage;
    // }
}

std::shared_ptr<Message> MailProcessor::insertMessage(IMAPMessage *mMsg, Folder &folder, time_t syncDataTimestamp) {
    std::shared_ptr<Message> msg = std::make_shared<Message>(nullptr, mMsg, folder, syncDataTimestamp);
    std::shared_ptr<Thread> thread = nullptr;

    Array *references = mMsg->header()->references();
    if (references == nullptr) {
        references = new Array();
        references->autorelease();
    }

    {
        QSqlDatabase db = m_worker->getDB();
        db.transaction();

        // find the correct thread, if it exists

        if (mMsg->gmailThreadID()) {
            
            QSqlQuery query{db};
            query.prepare(QStringLiteral("SELECT * FROM thread WHERE gmailThreadId = ?"));
            query.addBindValue((unsigned long long) mMsg->gmailThreadID());
            Utils::execWithLog(query, "insertMessage - fetch thread from gmail thread id");
            
            if (query.next()) {
                thread = std::make_shared<Thread>(nullptr, query);
            }

        } else if (!mMsg->header()->isMessageIDAutoGenerated()) {
            // find an existing thread using the references. Note - a rogue client could
            // throw a lot of stuff in here, limit the number of refs we look at to 50.
            // TODO: It appears we should technically use the first 1 and then last 49.
            int refcount = std::min(50, (int)references->count());

            QSqlQuery query{db};
            query.prepare(QString(QStringLiteral("SELECT * FROM thread INNER JOIN thread_reference ON thread_reference.threadId = thread.id WHERE thread_reference.accountId = ? AND thread_reference.headerMessageId IN (%1) LIMIT 1"))
                .arg(Utils::qmarks(1 + refcount)));
            query.bindValue(0, msg->accountId());
            query.bindValue(1, msg->headerMessageId());
            Utils::execWithLog(query, "insertMessage - join thread ref table and thread table");
            
            for (int i = 0; i < refcount; i ++) {
                String *ref = (String *)references->objectAtIndex(i);
                query.bindValue(2 + i, QString::fromUtf8(ref->UTF8Characters()));
            }

            if (query.next()) {
                thread = std::make_shared<Thread>(nullptr, query);
            }
        }

        // create the thread otherwise
        if (thread == nullptr) {
            thread = std::make_shared<Thread>(nullptr, m_worker->account()->id(), msg->subject(), QString::number(mMsg->gmailThreadID()));
        }

        msg->setThreadId(thread->id());

        // Index the thread metadata for search. We only do this once and it'd
        // be costly to make it part of the save hooks.
        appendToThreadSearchContent(thread.get(), msg.get(), nullptr);
        thread->saveToDb(db);

        // save message: - this will automatically update the thread with information.
        msg->saveToDb(db);

        // make the thread accessible by all of the message references
        upsertThreadReferences(thread->id(), thread->accountId(), msg->headerMessageId(), references);
        
        db.commit();
    }
    return msg;
}

void MailProcessor::retrievedMessageBody(Message *message, MessageParser *parser) {
    CleanHTMLBodyRendererTemplateCallback * htmlCallback = new CleanHTMLBodyRendererTemplateCallback();
    const char * bodyRepresentation;
    bool bodyIsPlaintext;

    Array * partAttachments = Array::array();
    Array * htmlInlineAttachments = Array::array();

    String *html = parser->htmlRenderingAndAttachments(htmlCallback, partAttachments, htmlInlineAttachments);
    String *text = html;

    if (html->hasPrefix(MCSTR("PLAINTEXT:"))) {
        text = html->substringFromIndex(10);
        bodyRepresentation = text->UTF8Characters();
        bodyIsPlaintext = true;
    } else {
        text = html->flattenHTML()->stripWhitespace();
        bodyRepresentation = html->UTF8Characters();
        bodyIsPlaintext = false;
    }
    MC_SAFE_RELEASE(htmlCallback);

    // build file containers for the attachments and write them to disk
    Array attachments = Array();
    attachments.addObjectsFromArray(partAttachments);
    attachments.addObjectsFromArray(htmlInlineAttachments);

    QList<std::shared_ptr<File>> files;

    for (unsigned int i = 0; i < attachments.count(); ++i) {
        Attachment * a = (Attachment *) attachments.objectAtIndex(i);
        if (a->contentID() && a->isInlineAttachment() == false) {
            // This is suspicious - the item has a content ID but we don't think it's an attachment?
            // Look in the content of the message for "cid:XXX". If we find it, the MIME was missing
            // the Content-Disposition but the client should render it inline.
            if (html->locationOfString(MCSTR("cid:")->stringByAppendingString(a->contentID())) != -1) {
                a->setInlineAttachment(true);
            }
        }

        std::shared_ptr<File> f = std::make_shared<File>(nullptr, message, a);

        bool duplicate = false;
        for (auto &other : files) {
            if (other->partId() == QString::fromUtf8(a->partID()->UTF8Characters())) {
                duplicate = true;
                qDebug() << "Attachment is duplicate: " << f->toJson();
                break;
            }
        }

        // Sometimes the HTML will reference "cid:filename.png@123123garbage" and the file will
        // not have a contentId. The client does not support this, so if cid:filename.png appears
        // in the body we manually make it the contentId
        QString cidFileName = QStringLiteral("cid:") + f->fileName();
        if (f->contentId().isEmpty() && strstr(bodyRepresentation, cidFileName.toStdString().c_str()) != nullptr) {
            f->setContentId(f->fileName());
        }

        if (!duplicate) {
            if (!retrievedFileData(f.get(), a->data())) {
                qDebug() << "Could not save file data!";
            }
            files.push_back(f);
        }
    }

    // enter transaction
    {
        QSqlDatabase db = m_worker->getDB();
        db.transaction();

        // write body to the MessageBodies table
        QSqlQuery query{db};
        query.prepare(QStringLiteral("REPLACE INTO message_body (id, value, fetchedAt) VALUES (?, ?, datetime('now'))"));
        query.bindValue(0, message->id());
        query.bindValue(1, QString::fromLatin1(bodyRepresentation));
        Utils::execWithLog(query, "retrievedMessageBody - replace message body");

        // write files to the files table
        for (auto &file : files) {
            file->saveToDb(db);
        }

        // append the body text to the thread's FTS5 search index
        query.prepare(QStringLiteral("SELECT * FROM thread WHERE id = ?"));
        query.addBindValue(message->threadId());
        Utils::execWithLog(query, "retrievedMessageBody - fetch folder");
        
        if (query.next()) {
            std::shared_ptr<Thread> thread = std::make_shared<Thread>(nullptr, query);
            appendToThreadSearchContent(thread.get(), nullptr, text);
        }

        message->setSnippet(QString::fromUtf8(text->substringToIndex(400)->UTF8Characters()));
        message->setPlaintext(bodyIsPlaintext);
        // TODO determine dispatch
        // message->setBodyForDispatch(bodyRepresentation);
        message->setFiles(files);

        message->saveToDb(db);

        db.commit();
    }
}


bool MailProcessor::retrievedFileData(File *file, Data * data) {
    QString path = RAVEN_DATA_LOCATION + QStringLiteral("/files/") + file->id();
    return (data->writeToFile(AS_MCSTR(path.toStdString())) == ErrorNone);
}

void MailProcessor::unlinkMessagesMatchingQuery(QSqlQuery &query, int phase)
{
    qDebug() << "Unlinking messages no longer present in remote range.";

    {
        QSqlDatabase db = m_worker->getDB();
        db.transaction();

        if (!Utils::execWithLog(query, "unlinkMessagesMatchingQuery - fetch messages to delete")) {
            qDebug() << query.lastQuery();
            return;
        }

        QList<std::shared_ptr<Message>> deletedMsgs;
        while (query.next()) {
            deletedMsgs.push_back(std::make_shared<Message>(nullptr, query));
        }

        bool logSubjects = deletedMsgs.size() < 20;

        qDebug() << "-- " << deletedMsgs.size() << " matches.";

        for (const auto &msg : deletedMsgs) {
            if (msg->remoteUid() > UINT32_MAX - 5) {
                // we unlinked this message in a previous cycle and it will be deleted momentarily.
                continue;
            }

            // don't spam the logs when a zillion messages are being deleted
            if (logSubjects) {
                qDebug() << "-- Unlinking \"" << msg->subject() << "\" (" << msg->id() << ")";
            }
            msg->setRemoteUid(QString::number(UINT32_MAX - phase));
            msg->saveToDb(db);
        }

        db.commit();
    }
}

void MailProcessor::deleteMessagesStillUnlinkedFromPhase(int phase)
{
    bool more = true;
    int chunkSize = 100;
    int iterations = 0;

    // If the user deletes (and we unlink) a zillion messages, we:
    //
    // - Delete 100 per transaction to avoid creating a very long-running transaction
    //
    // - Bail after 10 iterations. There's really no harm in deleting messages slowly
    //   since we've unlinked them and they're not visible in the client. We might
    //   even discover we want them again after all in a large new folder we're pulling
    //   down in chunks.

    while (more && iterations < 10) {
        QSqlDatabase db = m_worker->getDB();
        db.transaction();

        ++iterations;

        QSqlQuery query{db};
        query.prepare(QStringLiteral("SELECT * FROM message WHERE accountId = ? AND remoteUID = ? LIMIT ?"));
        query.addBindValue(m_worker->account()->id());
        query.addBindValue(UINT32_MAX - phase);
        query.addBindValue(chunkSize);

        Utils::execWithLog(query, "deleteMessagesStillUnlinkedFromPhase - select unlinked messages");

        QList<std::shared_ptr<Message>> messages;
        while (query.next()) {
            messages.push_back(std::make_shared<Message>(nullptr, query));
        }

        if (messages.size() < chunkSize){
            more = false;
        }

        if (messages.size()) {
            qDebug() << "-- Removing " << messages.size() << " unlinked messages";
        }
        for (auto const &msg : messages) {
            if (iterations == 1 && !more) { // only log subjects if <100 total
                qDebug() << "-- Removing \"" << msg->subject() << "\" (" << msg->id() << ")";
            }
            msg->deleteFromDb(db);
        }

        // send the deltas
        db.commit();
    }
}

void MailProcessor::appendToThreadSearchContent(Thread *thread, Message *messageToAppendOrNull, String * bodyToAppendOrNull) {
    // TODO
    // QString to;
    // QString from;
    // QString categories = thread->categoriesSearchString();
    // QString body;
    // 
    // // retrieve the current index if there is one
    // if (thread->searchRowId()) {
    //     SQLite::Statement existing(store->db(), "SELECT to_, from_, body FROM ThreadSearch WHERE rowid = ?");
    //     existing.bind(1, (double)thread->searchRowId());
    //     if (existing.executeStep()) {
    //         to = existing.getColumn("to_").getString();
    //         from = existing.getColumn("from_").getString();
    //         body = existing.getColumn("body").getString();
    //     }
    // }
    // 
    // if (messageToAppendOrNull != nullptr) {
    //     for (auto c : messageToAppendOrNull->to()) {
    //         if (c.count("email")) { to = stringByAppendingOrSkipping(to, c["email"].get<string>()); }
    //         if (c.count("name")) { to = stringByAppendingOrSkipping(to, c["name"].get<string>()); }
    //     }
    //     for (auto c : messageToAppendOrNull->cc()) {
    //         if (c.count("email")) { to = stringByAppendingOrSkipping(to, c["email"].get<string>()); }
    //         if (c.count("name")) { to = stringByAppendingOrSkipping(to, c["name"].get<string>()); }
    //     }
    //     for (auto c : messageToAppendOrNull->bcc()) {
    //         if (c.count("email")) { to = stringByAppendingOrSkipping(to, c["email"].get<string>()); }
    //         if (c.count("name")) { to = stringByAppendingOrSkipping(to, c["name"].get<string>()); }
    //     }
    //     for (auto c : messageToAppendOrNull->from()) {
    //         if (c.count("email")) { from = stringByAppendingOrSkipping(from, c["email"].get<string>()); }
    //         if (c.count("name")) { from = stringByAppendingOrSkipping(from, c["name"].get<string>()); }
    //     }
    // }
    // 
    // if (bodyToAppendOrNull != nullptr) {
    //     body += QStringLiteral(" ") + QString::fromUtf8(bodyToAppendOrNull->substringToIndex(5000)->UTF8Characters());
    // }
    // 
    // if (thread->searchRowId()) {
    //     SQLite::Statement update(store->db(), "UPDATE ThreadSearch SET to_ = ?, from_ = ?, body = ?, categories = ? WHERE rowid = ?");
    //     update.bind(1, to);
    //     update.bind(2, from);
    //     update.bind(3, body);
    //     update.bind(4, categories);
    //     update.bind(5, (double)thread->searchRowId());
    //     update.exec();
    // } else {
    //     SQLite::Statement insert(store->db(), "INSERT INTO ThreadSearch (subject, to_, from_, body, categories, content_id) VALUES (?, ?, ?, ?, ?, ?)");
    //     insert.bind(1, thread->subject());
    //     insert.bind(2, to);
    //     insert.bind(3, from);
    //     insert.bind(4, body);
    //     insert.bind(5, categories);
    //     insert.bind(6, thread->id());
    //     insert.exec();
    //     thread->setSearchRowId(store->db().getLastInsertRowid());
    // }
}

void MailProcessor::upsertThreadReferences(QString threadId, QString accountId, QString headerMessageId, Array *references) {
    QSqlDatabase db = m_worker->getDB();

    QSqlQuery query{db};
    query.prepare(QStringLiteral("INSERT OR IGNORE INTO thread_reference (threadId, accountId, headerMessageId) VALUES (?,?,?)"));
    query.bindValue(0, threadId);
    query.bindValue(1, accountId);
    query.bindValue(2, headerMessageId);
    Utils::execWithLog(query, "upsertThreadReferences");

    for (int i = 0; i < std::min(100, (int)references->count()); i ++) {
        String *address = (String*)references->objectAtIndex(i);
        query.bindValue(2, QString::fromUtf8(address->UTF8Characters()));
        query.exec();
    }
}
